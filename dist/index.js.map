{"version":3,"sources":["../src/sql-logic.ts","../src/pipe.ts","../src/sql-logic-utils.ts"],"sourcesContent":["import knex from \"knex\";\nimport { nanoid } from \"nanoid\";\nimport { buildKnexQueryFromGoals } from \"./sql-logic-utils.js\";\nimport type {\n\tColumnValue,\n\tConstraintInfo,\n\tGoalInfo,\n\tOrConstraintInfo,\n\tPredicateInfo,\n\tSqlLogicOptions,\n\tUnionInfo,\n\tVar,\n} from \"./types.js\";\n\nexport function isVar(v: unknown): v is Var {\n\tif (\n\t\tv &&\n\t\ttypeof v === \"object\" &&\n\t\tv !== null &&\n\t\t\"type\" in v &&\n\t\t(v as { type: string }).type === \"var\"\n\t) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nexport function getVarId(v: unknown) {\n\tif (isVar(v)) {\n\t\treturn v.id;\n\t}\n\treturn null;\n}\n\nexport class SqlLogic {\n\t#db: import(\"knex\").Knex;\n\t#logSql: boolean = true;\n\t#vars: Map<string, Var> = new Map();\n\n\tconstructor(options: SqlLogicOptions) {\n\t\tthis.#db = knex(options.db);\n\t\tthis.#logSql = options.logSql ?? false;\n\t}\n\n\ttable(name: string) {\n\t\treturn function query(\n\t\t\tobj: Record<string, ColumnValue | Var>,\n\t\t): PredicateInfo {\n\t\t\treturn {\n\t\t\t\ttype: \"predicate\" as const,\n\t\t\t\ttable: name,\n\t\t\t\tcolumns: Object.entries(obj).map(([column, value]) => ({\n\t\t\t\t\tcolumn,\n\t\t\t\t\toperator: \"=\",\n\t\t\t\t\tvalue,\n\t\t\t\t})),\n\t\t\t};\n\t\t};\n\t}\n\n\tquery(...goals: Array<GoalInfo | GoalInfo[]>): GoalInfo[] {\n\t\treturn this.conj(...goals);\n\t}\n\n\tvar(name?: string): Var {\n\t\tconst id = nanoid();\n\t\tname ??= id;\n\t\tconst thisVar = {\n\t\t\ttype: \"var\" as const,\n\t\t\tid,\n\t\t\tname,\n\t\t};\n\t\tthis.#vars.set(id, thisVar);\n\t\treturn thisVar;\n\t}\n\n\tasync runToArray(goals: GoalInfo[]): Promise<any[]> {\n\t\tconst kQuery = buildKnexQueryFromGoals(this.#db, goals);\n\t\tif (this.#logSql) {\n\t\t\tconsole.log(`[SQL] ${kQuery.toString()}`);\n\t\t}\n\t\treturn await kQuery;\n\t}\n\n\tconj(...goals: Array<GoalInfo | GoalInfo[]>): GoalInfo[] {\n\t\treturn goals.flatMap((g) => (Array.isArray(g) ? g : [g]));\n\t}\n\n\tdisj(...goals: GoalInfo[]): UnionInfo {\n\t\treturn {\n\t\t\ttype: \"union\",\n\t\t\tqueries: goals,\n\t\t};\n\t}\n\n\t// CONSTRAINTS\n\torConstraint(clauses: ConstraintInfo[]) {\n\t\treturn {\n\t\t\ttype: \"or_constraint\" as const,\n\t\t\tclauses,\n\t\t};\n\t}\n\n\tgt(variable: Var, value: ColumnValue) {\n\t\treturn {\n\t\t\ttype: \"constraint\" as const,\n\t\t\tvariable,\n\t\t\toperator: \">\",\n\t\t\tvalue,\n\t\t};\n\t}\n\n\tgte(variable: Var, value: ColumnValue) {\n\t\treturn {\n\t\t\ttype: \"constraint\" as const,\n\t\t\tvariable,\n\t\t\toperator: \">=\",\n\t\t\tvalue,\n\t\t};\n\t}\n\n\tlt(variable: Var, value: ColumnValue) {\n\t\treturn {\n\t\t\ttype: \"constraint\" as const,\n\t\t\tvariable,\n\t\t\toperator: \"<\",\n\t\t\tvalue,\n\t\t};\n\t}\n\n\tlte(variable: Var, value: ColumnValue) {\n\t\treturn {\n\t\t\ttype: \"constraint\" as const,\n\t\t\tvariable,\n\t\t\toperator: \"<=\",\n\t\t\tvalue,\n\t\t};\n\t}\n\n\tneq(variable: Var, value: ColumnValue) {\n\t\treturn {\n\t\t\ttype: \"constraint\" as const,\n\t\t\tvariable,\n\t\t\toperator: \"!=\",\n\t\t\tvalue,\n\t\t};\n\t}\n\n\teq(variable: Var, value: ColumnValue) {\n\t\treturn {\n\t\t\ttype: \"constraint\" as const,\n\t\t\tvariable,\n\t\t\toperator: \"=\",\n\t\t\tvalue,\n\t\t};\n\t}\n\n\tin(variable: Var, value: ColumnValue[]) {\n\t\treturn {\n\t\t\ttype: \"constraint\" as const,\n\t\t\tvariable,\n\t\t\toperator: \"IN\",\n\t\t\tvalue,\n\t\t};\n\t}\n\n\tnotIn(variable: Var, value: ColumnValue[]) {\n\t\treturn {\n\t\t\ttype: \"constraint\" as const,\n\t\t\tvariable,\n\t\t\toperator: \"NOT IN\",\n\t\t\tvalue,\n\t\t};\n\t}\n}\n// Type guards\nexport function isTypedObject(obj: unknown): obj is { type: string } {\n\tif (\n\t\tobj &&\n\t\tobj !== null &&\n\t\t!Array.isArray(obj) &&\n\t\ttypeof obj === \"object\" &&\n\t\t\"type\" in obj\n\t) {\n\t\treturn true;\n\t}\n\treturn false;\n}\nexport function isConstraintInfo(obj: unknown): obj is ConstraintInfo {\n\tif (isTypedObject(obj) && obj.type === \"constraint\" && \"variable\" in obj) {\n\t\treturn true;\n\t}\n\treturn false;\n}\nexport function isPredicateInfo(obj: unknown): obj is PredicateInfo {\n\tif (\n\t\tisTypedObject(obj) &&\n\t\tobj.type === \"predicate\" &&\n\t\t\"table\" in obj &&\n\t\t\"column\" in obj &&\n\t\t\"operator\" in obj &&\n\t\t\"value\" in obj\n\t) {\n\t\treturn true;\n\t}\n\treturn false;\n}\nexport function isOrConstraint(obj: unknown): obj is OrConstraintInfo {\n\treturn (\n\t\tisTypedObject(obj) &&\n\t\tobj.type === \"or_constraint\" &&\n\t\t\"clauses\" in obj &&\n\t\tArray.isArray(obj.clauses)\n\t);\n}\n","// Pipe function with proper TypeScript overloads\nexport function pipe<T>(value: T): T;\nexport function pipe<T, R1>(value: T, fn1: (arg: T) => R1): R1;\nexport function pipe<T, R1, R2>(\n\tvalue: T,\n\tfn1: (arg: T) => R1,\n\tfn2: (arg: R1) => R2,\n): R2;\nexport function pipe<T, R1, R2, R3>(\n\tvalue: T,\n\tfn1: (arg: T) => R1,\n\tfn2: (arg: R1) => R2,\n\tfn3: (arg: R2) => R3,\n): R3;\nexport function pipe<T, R1, R2, R3, R4>(\n\tvalue: T,\n\tfn1: (arg: T) => R1,\n\tfn2: (arg: R1) => R2,\n\tfn3: (arg: R2) => R3,\n\tfn4: (arg: R3) => R4,\n): R4;\nexport function pipe<T, R1, R2, R3, R4, R5>(\n\tvalue: T,\n\tfn1: (arg: T) => R1,\n\tfn2: (arg: R1) => R2,\n\tfn3: (arg: R2) => R3,\n\tfn4: (arg: R3) => R4,\n\tfn5: (arg: R4) => R5,\n): R5;\nexport function pipe<T, R1, R2, R3, R4, R5, R6>(\n\tvalue: T,\n\tfn1: (arg: T) => R1,\n\tfn2: (arg: R1) => R2,\n\tfn3: (arg: R2) => R3,\n\tfn4: (arg: R3) => R4,\n\tfn5: (arg: R4) => R5,\n\tfn6: (arg: R5) => R6,\n): R6;\nexport function pipe<T, R1, R2, R3, R4, R5, R6, R7>(\n\tvalue: T,\n\tfn1: (arg: T) => R1,\n\tfn2: (arg: R1) => R2,\n\tfn3: (arg: R2) => R3,\n\tfn4: (arg: R3) => R4,\n\tfn5: (arg: R4) => R5,\n\tfn6: (arg: R5) => R6,\n\tfn7: (arg: R6) => R7,\n): R7;\nexport function pipe<T, R1, R2, R3, R4, R5, R6, R7, R8>(\n\tvalue: T,\n\tfn1: (arg: T) => R1,\n\tfn2: (arg: R1) => R2,\n\tfn3: (arg: R2) => R3,\n\tfn4: (arg: R3) => R4,\n\tfn5: (arg: R4) => R5,\n\tfn6: (arg: R5) => R6,\n\tfn7: (arg: R6) => R7,\n\tfn8: (arg: R7) => R8,\n): R8;\nexport function pipe(value: any, ...fns: Array<(arg: any) => any>): any {\n\treturn fns.reduce((acc, fn) => fn(acc), value);\n}\n\n// Array utilities\nexport const filterByType = <T extends { type: string }, K extends T[\"type\"]>(\n\titems: T[],\n\ttype: K,\n): Extract<T, { type: K }>[] =>\n\titems.filter((item): item is Extract<T, { type: K }> => item.type === type);\n\nexport const groupBy = <T, K extends string | number | symbol>(\n\titems: T[],\n\tkeyFn: (item: T) => K,\n): Record<K, T[]> =>\n\titems.reduce(\n\t\t(acc, item) => {\n\t\t\tconst key = keyFn(item);\n\t\t\treturn { ...acc, [key]: [...(acc[key] || []), item] };\n\t\t},\n\t\t{} as Record<K, T[]>,\n\t);\n\nexport const mapWithIndex = <T, R>(\n\titems: T[],\n\tfn: (item: T, index: number) => R,\n): R[] => items.map(fn);\n\n// Object utilities\nexport const mapValues = <T, R>(\n\tobj: Record<string, T>,\n\tfn: (value: T) => R,\n): Record<string, R> =>\n\tObject.fromEntries(\n\t\tObject.entries(obj).map(([key, value]) => [key, fn(value)]),\n\t);\n\nexport const pickBy = <T>(\n\tobj: Record<string, T>,\n\tpredicate: (value: T, key: string) => boolean,\n): Record<string, T> =>\n\tObject.fromEntries(\n\t\tObject.entries(obj).filter(([key, value]) => predicate(value, key)),\n\t);\n\n// Set utilities\nexport const hasIntersection = <T>(set1: Set<T>, set2: Set<T>): boolean =>\n\tArray.from(set1).some((item) => set2.has(item));\n\nexport const someWithIndex = <T>(\n\titems: T[],\n\tpredicate: (item: T, index: number) => boolean,\n): boolean => items.some(predicate);\n","/** biome-ignore-all lint/style/noNonNullAssertion: <explanation> */\n// import * as R from \"ramda\";\nimport type { Knex } from \"knex\";\nimport {\n\tfilterByType,\n\tgroupBy,\n\thasIntersection,\n\tpipe,\n\tsomeWithIndex,\n} from \"./pipe.js\";\nimport { getVarId, isVar } from \"./sql-logic.js\";\nimport type {\n\tColumnInfo,\n\tColumnValue,\n\tConstraintInfo,\n\tGoalInfo,\n\tOrConstraintInfo,\n\tPredicateInfo,\n\tUnionInfo,\n} from \"./types.js\";\n\ntype QueryBuilder = Knex.QueryBuilder;\n\nconst createWhereClause =\n\t(\n\t\talias: string,\n\t\tcolumn: string,\n\t\toperator: string,\n\t\tvalue: ColumnValue | ColumnValue[],\n\t) =>\n\t(qb: QueryBuilder) => {\n\t\tconst columnRef = `${alias}.${column}`;\n\t\tconst processedValue =\n\t\t\t(operator === \"IN\" || operator === \"NOT IN\") && !Array.isArray(value)\n\t\t\t\t? [value]\n\t\t\t\t: value;\n\n\t\tif (operator === \"IN\") {\n\t\t\treturn qb.whereIn(columnRef, processedValue as readonly ColumnValue[]);\n\t\t}\n\t\tif (operator === \"NOT IN\") {\n\t\t\treturn qb.whereNotIn(columnRef, processedValue as readonly ColumnValue[]);\n\t\t}\n\t\treturn qb.where(columnRef, processedValue);\n\t};\n\nconst createOrWhereClause = (\n\talias: string,\n\tcolumn: string,\n\toperator: string,\n\tvalue: ColumnValue | ColumnValue[],\n) =>\n\tfunction (this: Knex.QueryBuilder) {\n\t\tconst columnRef = `${alias}.${column}`;\n\t\tconst processedValue =\n\t\t\t(operator === \"IN\" || operator === \"NOT IN\") && !Array.isArray(value)\n\t\t\t\t? [value]\n\t\t\t\t: value;\n\n\t\tif (operator === \"IN\") {\n\t\t\tthis.orWhereIn(columnRef, processedValue as readonly ColumnValue[]);\n\t\t} else if (operator === \"NOT IN\") {\n\t\t\tthis.orWhereNotIn(columnRef, processedValue as readonly ColumnValue[]);\n\t\t} else {\n\t\t\tthis.orWhere(columnRef, processedValue);\n\t\t}\n\t};\n\nconst applyQueryModifiers = (\n\tqb: QueryBuilder,\n\tmodifiers: Array<(qb: QueryBuilder) => QueryBuilder>,\n) => modifiers.reduce((acc, modifier) => modifier(acc), qb);\n\nexport function applySelects(selectColumns: VarLocation[]) {\n\treturn (qb: QueryBuilder) =>\n\t\tselectColumns.length > 0\n\t\t\t? qb.select(\n\t\t\t\t\tselectColumns.map((s) => `${s.alias}.${s.column} as ${s.varName}`),\n\t\t\t\t)\n\t\t\t: qb;\n}\n\nexport function applyJoins(\n\tvarLocations: Record<\n\t\tstring,\n\t\t{ alias: string; table: string; column: string }[]\n\t>,\n): (qb: QueryBuilder) => QueryBuilder {\n\treturn (qb: QueryBuilder) => {\n\t\treturn pipe(\n\t\t\tObject.values(varLocations),\n\t\t\t(locations) => locations.filter((locs) => locs.length > 1),\n\t\t\t(locations) =>\n\t\t\t\tlocations.flatMap((locs) =>\n\t\t\t\t\tlocs.flatMap((t1, i) =>\n\t\t\t\t\t\tlocs.slice(i + 1).map((t2) => ({\n\t\t\t\t\t\t\tt1,\n\t\t\t\t\t\t\tt2,\n\t\t\t\t\t\t\tpairKey: [t1.alias, t2.alias].sort().join(\"::\"),\n\t\t\t\t\t\t})),\n\t\t\t\t\t),\n\t\t\t\t),\n\t\t\t(pairs) =>\n\t\t\t\tpairs.reduce(\n\t\t\t\t\t(acc, { t1, t2, pairKey }) => {\n\t\t\t\t\t\tif (!acc.seen.has(pairKey)) {\n\t\t\t\t\t\t\tacc.pairs.push([t1, t2]);\n\t\t\t\t\t\t\tacc.seen.add(pairKey);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn acc;\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\tpairs: [] as Array<\n\t\t\t\t\t\t\t[(typeof pairs)[0][\"t1\"], (typeof pairs)[0][\"t2\"]]\n\t\t\t\t\t\t>,\n\t\t\t\t\t\tseen: new Set<string>(),\n\t\t\t\t\t},\n\t\t\t\t),\n\t\t\t(result) => result.pairs,\n\t\t\t(pairs) =>\n\t\t\t\tpairs.reduce(\n\t\t\t\t\t(builder, [t1, t2]) =>\n\t\t\t\t\t\tbuilder.join({ [t2.alias]: t2.table }, function () {\n\t\t\t\t\t\t\tthis.on(\n\t\t\t\t\t\t\t\t`${t1.alias}.${t1.column}`,\n\t\t\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\t\t`${t2.alias}.${t2.column}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}),\n\t\t\t\t\tqb,\n\t\t\t\t),\n\t\t);\n\t};\n}\n\nexport function applyPredicateWheres(predicates: PredicateInfo[]) {\n\treturn (qb: QueryBuilder) => {\n\t\tconst modifiers = predicates\n\t\t\t.filter((pred) => pred.alias)\n\t\t\t.flatMap((pred) =>\n\t\t\t\tpred.columns\n\t\t\t\t\t.filter(\n\t\t\t\t\t\t(col): col is ColumnInfo & { value: ColumnValue } =>\n\t\t\t\t\t\t\t!isVar(col.value),\n\t\t\t\t\t)\n\t\t\t\t\t.map((col) =>\n\t\t\t\t\t\tcreateWhereClause(pred.alias!, col.column, col.operator, col.value),\n\t\t\t\t\t),\n\t\t\t);\n\n\t\treturn applyQueryModifiers(qb, modifiers);\n\t};\n}\n\nexport function applyOrConstraint(\n\tqb: QueryBuilder,\n\tor: OrConstraintInfo,\n\tvarLocations: Record<\n\t\tstring,\n\t\t{ alias: string; table: string; column: string }[]\n\t>,\n): QueryBuilder {\n\tconst orClauses = or.clauses.flatMap((clause) => {\n\t\tconst varId = getVarId(clause.variable);\n\t\tconst locs = varId ? varLocations[varId] || [] : [];\n\t\treturn locs.map((loc) =>\n\t\t\tcreateOrWhereClause(loc.alias, loc.column, clause.operator, clause.value),\n\t\t);\n\t});\n\n\treturn qb.where(function () {\n\t\torClauses.forEach((orClause) => orClause.call(this));\n\t});\n}\n\nexport function applyAllOrConstraints(\n\torConstraints: OrConstraintInfo[],\n\tvarLocations: Record<\n\t\tstring,\n\t\t{ alias: string; table: string; column: string }[]\n\t>,\n) {\n\treturn (qb: QueryBuilder) =>\n\t\torConstraints.reduce(\n\t\t\t(acc, or) => acc.modify((q) => applyOrConstraint(q, or, varLocations)),\n\t\t\tqb,\n\t\t);\n}\n\ninterface VarLocation {\n\tvarId: string;\n\talias: string;\n\ttable: string;\n\tcolumn: string;\n\tvarName: string;\n}\n\nfunction splitGoals(goals: GoalInfo[]) {\n\tconst flattenGoals = (goals: GoalInfo[]): GoalInfo[] =>\n\t\tgoals.flatMap((g) =>\n\t\t\tg.type === \"union\"\n\t\t\t\t? g.queries.flatMap((branch) =>\n\t\t\t\t\t\tflattenGoals(Array.isArray(branch) ? branch : [branch]),\n\t\t\t\t\t)\n\t\t\t\t: [g],\n\t\t);\n\n\tconst allGoals = flattenGoals(goals);\n\n\treturn {\n\t\tpredicates: filterByType(allGoals, \"predicate\"),\n\t\tconstraints: filterByType(allGoals, \"constraint\"),\n\t\torConstraints: filterByType(allGoals, \"or_constraint\"),\n\t\tunions: filterByType(goals, \"union\"),\n\t};\n}\n\nconst makePredicateWithAliases = (predicates: PredicateInfo[]) =>\n\tpredicates.map((pred, i) => ({\n\t\t...pred,\n\t\talias: `t${i + 1}`,\n\t}));\n\nconst makeSelectColumns = (varLocations: Record<string, VarLocation[]>) =>\n\tObject.values(varLocations)\n\t\t.map((locations) => locations[0])\n\t\t.filter((location): location is VarLocation => location != null);\n\nconst createVarLocation = (\n\tpred: PredicateInfo,\n\tcol: ColumnInfo,\n): VarLocation | null => {\n\tconst varId = getVarId(col.value);\n\treturn varId && pred.alias\n\t\t? {\n\t\t\t\tvarId,\n\t\t\t\talias: pred.alias,\n\t\t\t\ttable: pred.table,\n\t\t\t\tcolumn: col.column,\n\t\t\t\tvarName: (col.value as { name: string }).name,\n\t\t\t}\n\t\t: null;\n};\n\nconst extractVarLocationsFromPredicate = (pred: PredicateInfo): VarLocation[] =>\n\tpred.columns\n\t\t.filter((col) => isVar(col.value))\n\t\t.map((col) => createVarLocation(pred, col))\n\t\t.filter((x): x is VarLocation => x !== null);\n\nconst makeVarLocations = (predicates: PredicateInfo[]) =>\n\tpipe(\n\t\tpredicates,\n\t\t(preds) => preds.flatMap(extractVarLocationsFromPredicate),\n\t\t(locations) => groupBy(locations, (loc) => loc.varId),\n\t);\n\nfunction arePredicatesDisconnected(predicates: PredicateInfo[]) {\n\tconst varSets = predicates.map(\n\t\t(pred) =>\n\t\t\tnew Set(\n\t\t\t\tpred.columns\n\t\t\t\t\t.filter((c) => isVar(c.value))\n\t\t\t\t\t.map((c) => getVarId(c.value)),\n\t\t\t),\n\t);\n\n\tconst hasSharedVariable = someWithIndex(varSets, (set1, i) =>\n\t\tvarSets.slice(i + 1).some((set2) => hasIntersection(set1, set2)),\n\t);\n\n\treturn predicates.length > 1 && !hasSharedVariable;\n}\n\nconst applyCrossJoinsIfDisconnected =\n\t(predicates: PredicateInfo[]) => (qb: QueryBuilder) =>\n\t\t!arePredicatesDisconnected(predicates)\n\t\t\t? qb\n\t\t\t: predicates.slice(1).reduce(\n\t\t\t\t\t(acc, pred) =>\n\t\t\t\t\t\tacc.join(`${pred.table} as ${pred.alias!}`, () => {\n\t\t\t\t\t\t\t// Empty function creates a cross join (no ON clause)\n\t\t\t\t\t\t}),\n\t\t\t\t\tqb,\n\t\t\t\t);\n\nfunction applyUnions(unions: UnionInfo[], knex: Knex) {\n\treturn (qb: QueryBuilder) => {\n\t\tif (unions.length === 0) return qb;\n\n\t\t// Build all union subqueries\n\t\tconst subqueries = unions.flatMap((unionInfo) =>\n\t\t\tunionInfo.queries.map((subGoals) =>\n\t\t\t\tbuildKnexQueryFromGoals(\n\t\t\t\t\tknex,\n\t\t\t\t\tArray.isArray(subGoals) ? subGoals : [subGoals],\n\t\t\t\t),\n\t\t\t),\n\t\t);\n\n\t\tif (subqueries.length === 0) return qb;\n\n\t\t// Use the array form of union to add all subqueries at once\n\t\treturn qb.union(subqueries);\n\t};\n}\n\nfunction handleEmptyPredicates(): never {\n\tthrow new Error(\n\t\t\"No goals provided - cannot build query without predicates or unions\",\n\t);\n}\n\nconst createConstraintPipeline =\n\t<T>(\n\t\tgetVarId: (item: T) => string | null,\n\t\tcreateModifier: (loc: any, item: T) => (qb: QueryBuilder) => QueryBuilder,\n\t) =>\n\t(items: T[], varLocations: Record<string, any[]>) =>\n\t(qb: QueryBuilder) => {\n\t\tconst modifiers = flatMapLocations(\n\t\t\titems,\n\t\t\tgetVarId,\n\t\t\tvarLocations,\n\t\t\tcreateModifier,\n\t\t);\n\t\treturn applyQueryModifiers(qb, modifiers);\n\t};\n\nconst flatMapLocations = <T>(\n\titems: T[],\n\tgetVarId: (item: T) => string | null,\n\tvarLocations: Record<string, any[]>,\n\tcreateClause: (loc: any, item: T) => any,\n) =>\n\titems.flatMap((item) => {\n\t\tconst locs = getVariableLocations(getVarId(item), varLocations);\n\t\treturn locs.map((loc) => createClause(loc, item));\n\t});\n\nconst getVariableLocations = (\n\tvarId: string | null,\n\tvarLocations: Record<string, any[]>,\n) => (varId ? varLocations[varId] || [] : []);\n\nconst applyWhereConstraints = createConstraintPipeline(\n\t(constraint: ConstraintInfo) => getVarId(constraint.variable),\n\t(loc, constraint: ConstraintInfo) =>\n\t\tcreateWhereClause(\n\t\t\tloc.alias,\n\t\t\tloc.column,\n\t\t\tconstraint.operator,\n\t\t\tconstraint.value,\n\t\t),\n);\n\nexport function buildKnexQueryFromGoals(\n\tknex: Knex,\n\tgoals: GoalInfo[],\n): QueryBuilder {\n\t// Handle single union in array - use knex.union directly\n\tif (goals.length === 1 && goals[0]!.type === \"union\") {\n\t\tconst union = goals[0] as UnionInfo;\n\t\tconst subqueries = union.queries.map((subGoals) =>\n\t\t\tbuildKnexQueryFromGoals(\n\t\t\t\tknex,\n\t\t\t\tArray.isArray(subGoals) ? subGoals : [subGoals],\n\t\t\t),\n\t\t);\n\t\treturn knex.union(subqueries);\n\t}\n\n\t// Handle regular goals pipeline\n\tconst { predicates, constraints, orConstraints, unions } = splitGoals(goals);\n\tconst predicatesWithAliases = makePredicateWithAliases(predicates);\n\n\t// Handle case where there are no predicates\n\tif (predicatesWithAliases.length === 0) {\n\t\thandleEmptyPredicates();\n\t}\n\n\tconst varLocations = makeVarLocations(predicatesWithAliases);\n\tconst selectColumns = makeSelectColumns(varLocations);\n\n\tconst baseQuery = knex({\n\t\t[predicatesWithAliases[0]!.alias]: predicatesWithAliases[0]!.table,\n\t});\n\n\treturn pipe(\n\t\tbaseQuery,\n\t\tapplyCrossJoinsIfDisconnected(predicatesWithAliases),\n\t\tapplySelects(selectColumns),\n\t\tapplyJoins(varLocations),\n\t\tapplyWhereConstraints(constraints, varLocations),\n\t\tapplyPredicateWheres(predicatesWithAliases),\n\t\tapplyAllOrConstraints(orConstraints, varLocations),\n\t\tapplyUnions(unions, knex),\n\t);\n}\n"],"mappings":"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","names":["goals","knex","getVarId"]}